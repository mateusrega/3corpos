<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Teoria dos Três Corpos — Verlet + Rastros</title>
<style>
  :root {
    --bg: #000;
    --ui-bg: rgba(255,255,255,0.06);
    --ui-text: #ddd;
  }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--ui-text); font-family: Inter, Roboto, system-ui, sans-serif; }
  #container { position:relative; height:100vh; width:100vw; overflow:hidden; }
  canvas { display:block; background: linear-gradient(180deg, #030308 0%, #000000 100%); }
  /* UI mínima */
  .ui {
    position: absolute;
    left: 12px;
    top: 12px;
    background: var(--ui-bg);
    color: var(--ui-text);
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 13px;
    backdrop-filter: blur(4px);
  }
  .ui label { display:inline-block; margin-right:8px; }
  .ui input[type="range"] { vertical-align: middle; width:120px; }
  .ui .small { font-size:11px; opacity:0.9; }
  .footer {
    position: absolute;
    right: 12px;
    bottom: 12px;
    color: #999;
    font-size: 12px;
    background: rgba(255,255,255,0.03);
    padding:6px 8px;
    border-radius:6px;
  }
  button { background: transparent; border:1px solid rgba(255,255,255,0.08); color:var(--ui-text); padding:6px 8px; border-radius:6px; cursor:pointer; }
  button:active{ transform:translateY(1px); }
</style>
</head>
<body>
  <div id="container">
    <canvas id="sim"></canvas>

    <div class="ui" id="ui">
      <div style="margin-bottom:6px;"><strong>3-Corpos — Verlet</strong></div>
      <div>
        <label>dt</label>
        <input id="dtRange" type="range" min="0.1" max="3" step="0.1" value="1">
        <span id="dtVal" class="small">1.0</span>
      </div>
      <div style="margin-top:6px;">
        <label>G</label>
        <input id="gRange" type="range" min="0.01" max="1.0" step="0.01" value="0.2">
        <span id="gVal" class="small">0.20</span>
      </div>
      <div style="margin-top:6px;">
        <button id="resetBtn">Reset</button>
        <button id="addBtn">Adicionar corpo</button>
      </div>
      <div style="margin-top:6px;" class="small">Clique e arraste para adicionar corpo com velocidade inicial.</div>
    </div>

    <div class="footer">Rastro tracejado • máximo por corpo: 150</div>
  </div>

<script>
/*
  Simulação 3 corpos (2D) usando Velocity Verlet
  - Cores automáticas por massa
  - Rastros tracejados limitados (MAX_TRAIL)
  - UI mínima para dt e G
  - Arrastar no canvas para criar corpos com velocidade inicial
*/

// Canvas e contexto
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');

// UI
const dtRange = document.getElementById('dtRange');
const dtVal = document.getElementById('dtVal');
const gRange = document.getElementById('gRange');
const gVal = document.getElementById('gVal');
const resetBtn = document.getElementById('resetBtn');
const addBtn = document.getElementById('addBtn');

let DPR = Math.max(1, window.devicePixelRatio || 1);

// parâmetros
let G = parseFloat(gRange.value);    // constante gravitacional (visual)
let dt = parseFloat(dtRange.value);  // passo de tempo (fixo)
const MAX_TRAIL = 150;               // limite de pontos no rastro por corpo

// ajusta canvas para dpi
function resize() {
  DPR = Math.max(1, window.devicePixelRatio || 1);
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // escala para coordenadas CSS
}
window.addEventListener('resize', resize);
resize();

// util: gerar cor por massa (retorna array [r,g,b])
function corPorMassaRGB(m) {
  // normaliza entre 0 e 1 (ajuste as faixas conforme as massas que usar)
  const minM = 5;
  const maxM = 60;
  let t = (m - minM) / (maxM - minM);
  t = Math.max(0, Math.min(1, t));

  // gradiente: azul -> verde -> amarelo -> vermelho
  // vamos mapear t em duas fases para suavizar
  if (t < 0.5) {
    // azul (0,120,255) -> verde (0,200,80)
    let u = t / 0.5;
    let r = Math.round(0 + (0 - 0) * u);
    let g = Math.round(120 + (200 - 120) * u);
    let b = Math.round(255 + (80 - 255) * u);
    return [r,g,b];
  } else {
    // verde -> vermelho (255,120,30)
    let u = (t - 0.5) / 0.5;
    let r = Math.round(0 + (255 - 0) * u);
    let g = Math.round(200 + (120 - 200) * u);
    let b = Math.round(80 + (30 - 80) * u);
    return [r,g,b];
  }
}

// helper: rgb array -> css strings
function rgbToString(rgb) { return `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`; }
function rgbaToString(rgb, a) { return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`; }

// corpo factory
function corpo(m, x, y, vx=0, vy=0) {
  const rgb = corPorMassaRGB(m);
  return {
    m, x, y, vx, vy,
    rgb,
    trail: []
  };
}

// estado inicial: 3 corpos clássicos (mude se quiser)
let corpos = [
  corpo(20, window.innerWidth/2 - 150, window.innerHeight/2, 0, 1.2),
  corpo(20, window.innerWidth/2 + 150, window.innerHeight/2, 0, -1.2),
  corpo(35, window.innerWidth/2, window.innerHeight/2, 0, 0)
];

// função que calcula acelerações com base nas posições atuais
function calcularAceleracoes(arr) {
  const n = arr.length;
  const ax = new Array(n).fill(0);
  const ay = new Array(n).fill(0);

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const dx = arr[j].x - arr[i].x;
      const dy = arr[j].y - arr[i].y;
      const dist2 = dx*dx + dy*dy;
      const dist = Math.sqrt(dist2) + 1e-6; // evita div/0
      // força com suavização pequena (epsilon) para evitar valores gigantes
      const eps = 1.0; // ajuste se quiser menos suavização
      const f = G * arr[i].m * arr[j].m / (dist2 + eps);
      const fx = f * dx / dist;
      const fy = f * dy / dist;

      ax[i] += fx / arr[i].m;
      ay[i] += fy / arr[i].m;

      ax[j] -= fx / arr[j].m;
      ay[j] -= fy / arr[j].m;
    }
  }
  return { ax, ay };
}

// Velocity Verlet: atualização
function atualizarVerlet() {
  // 1) aceleração atual
  const { ax: ax0, ay: ay0 } = calcularAceleracoes(corpos);

  // 2) atualiza posições
  for (let i = 0; i < corpos.length; i++) {
    const c = corpos[i];
    c.x += c.vx * dt + 0.5 * ax0[i] * dt * dt;
    c.y += c.vy * dt + 0.5 * ay0[i] * dt * dt;
  }

  // 3) recalcula acelerações com novas posições
  const { ax: ax1, ay: ay1 } = calcularAceleracoes(corpos);

  // 4) atualiza velocidades
  for (let i = 0; i < corpos.length; i++) {
    const c = corpos[i];
    c.vx += 0.5 * (ax0[i] + ax1[i]) * dt;
    c.vy += 0.5 * (ay0[i] + ay1[i]) * dt;
  }

  // 5) atualiza trails (limite)
  for (let c of corpos) {
    c.trail.push({ x: c.x, y: c.y });
    if (c.trail.length > MAX_TRAIL) c.trail.shift();
  }
}

// desenha rastros e corpos
function desenhar() {
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  // desenha rastros tracejados
  ctx.lineWidth = 1;
  ctx.setLineDash([6,6]); // tracejado
  for (let c of corpos) {
    if (c.trail.length < 2) continue;
    ctx.beginPath();
    ctx.strokeStyle = rgbaToString(c.rgb, 0.28);
    for (let i = 0; i < c.trail.length - 1; i++) {
      const p1 = c.trail[i];
      const p2 = c.trail[i+1];
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // desenha corpos
  for (let c of corpos) {
    ctx.beginPath();
    // raio visual baseado na massa
    const raio = Math.max(4, Math.log(c.m + 1) * 4);
    ctx.arc(c.x, c.y, raio, 0, Math.PI*2);
    ctx.fillStyle = rgbToString(c.rgb);
    ctx.fill();

    // borda suave
    ctx.lineWidth = 1;
    ctx.strokeStyle = rgbaToString(c.rgb, 0.9);
    ctx.stroke();
  }
}

// loop principal
let last = performance.now();
function loop(now) {
  // nota: dt é o passo de simulação fixo controlado pela UI.
  // fazemos apenas tantos passos de dt quanto seja necessário para não ficar lento
  // (não é um integrador com substep baseado em tempo real — dt aqui controla a simulação)
  atualizarVerlet();
  desenhar();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// -- UI handlers --
dtRange.addEventListener('input', (e) => {
  dt = parseFloat(e.target.value);
  dtVal.textContent = dt.toFixed(2);
});
gRange.addEventListener('input', (e) => {
  G = parseFloat(e.target.value);
  gVal.textContent = G.toFixed(2);
});

// reset simples: recria a configuração inicial
function resetScene() {
  corpos = [
    corpo(20, window.innerWidth/2 - 150, window.innerHeight/2, 0, 1.2),
    corpo(20, window.innerWidth/2 + 150, window.innerHeight/2, 0, -1.2),
    corpo(35, window.innerWidth/2, window.innerHeight/2, 0, 0)
  ];
}
resetBtn.addEventListener('click', resetScene);

// adicionar corpo aleatório
addBtn.addEventListener('click', () => {
  // adiciona perto do centro com velocidade aleatória
  const x = window.innerWidth/2 + (Math.random()-0.5)*200;
  const y = window.innerHeight/2 + (Math.random()-0.5)*200;
  const vx = (Math.random()-0.5) * 2;
  const vy = (Math.random()-0.5) * 2;
  const m = 8 + Math.random() * 40;
  corpos.push(corpo(m, x, y, vx, vy));
});

// --- adicionar corpos por clique+arraste (arraste define velocidade inicial) ---
let isDown = false;
let downPos = null;
canvas.addEventListener('pointerdown', (ev) => {
  isDown = true;
  downPos = { x: ev.clientX, y: ev.clientY, time: performance.now() };
});
canvas.addEventListener('pointerup', (ev) => {
  if (!isDown || !downPos) { isDown = false; return; }
  const upPos = { x: ev.clientX, y: ev.clientY };
  const vx = (upPos.x - downPos.x) * 0.02; // escala de velocidade
  const vy = (upPos.y - downPos.y) * 0.02;
  // massa dependendo da duração do arrasto (mais tempo -> massa maior)
  const dtDrag = Math.max(1, performance.now() - downPos.time);
  const m = Math.min(60, 5 + dtDrag * 0.03);
  corpos.push(corpo(m, downPos.x, downPos.y, vx, vy));
  isDown = false;
  downPos = null;
});

// dica: evita seleção de texto durante arrasto
canvas.addEventListener('pointermove', (ev) => {
  if (isDown) ev.preventDefault();
});

// inicializa texto UI
dtVal.textContent = dt.toFixed(2);
gVal.textContent = G.toFixed(2);

// resize pra garantir que corpos iniciais estejam centrados corretamente após load
window.addEventListener('load', () => {
  resize();
});
</script>
</body>
</html>
