<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>3-Corpos — Mobile (Verlet + Pinch Zoom)</title>

<style>
  :root {
    --bg: #000;
    --panel: #0f1720;
    --accent: #0a84ff;
    --ui: #ddd;
  }

  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden;
    background: var(--bg);
    font-family: Arial, sans-serif;
    -webkit-user-select: none;
    user-select: none;
  }

  #canvas {
    touch-action: none;
    background: #000;
    display: block;
  }

  /* === Botão flutuante (abre painel) === */
  #uiBtn {
    position: fixed;
    top: 14px;
    left: 14px;
    z-index: 20;
    background: var(--accent);
    color: white;
    border: none;
    padding: 12px 16px;
    border-radius: 12px;
    font-size: 16px;
    cursor: pointer;
  }

  /* === Painel lateral === */
  #panel {
    position: fixed;
    top: 0;
    left: -260px;
    width: 260px;
    height: 100%;
    background: var(--panel);
    color: var(--ui);
    padding: 20px;
    box-shadow: 4px 0 20px #0008;
    z-index: 30;
    transition: left 0.32s ease;
    overflow-y: auto;
  }

  #panel.open {
    left: 0;
  }

  /* Botão fechar painel */
  #closePanelBtn {
    background: #d33;
    color: #fff;
    border: none;
    padding: 7px 10px;
    border-radius: 8px;
    margin-bottom: 12px;
    cursor: pointer;
    width: 100%;
  }

  h3 {
    margin-top: 18px;
    margin-bottom: 6px;
  }

  input[type="range"],
  input[type="number"] {
    width: 100%;
    margin: 6px 0;
  }

  button {
    margin-top: 10px;
    width: 100%;
    padding: 10px;
    border-radius: 10px;
    border: none;
    background: var(--accent);
    color: white;
    font-size: 15px;
  }

</style>
</head>

<body>
<canvas id="canvas"></canvas>

<button id="uiBtn">⚙️</button>

<div id="panel" aria-hidden="true">

  <button id="closePanelBtn">Fechar painel</button>

  <h3>Constantes</h3>
  <label id="gVal">G = 1.00</label>
  <input id="gRange" type="range" min="0.1" max="3" step="0.01" value="1">

  <label id="dtVal">dt = 1.00</label>
  <input id="dtRange" type="range" min="0.2" max="3" step="0.01" value="1">

  <h3>Novo Corpo</h3>
  Massa:
  <input id="massa" type="number" value="10">
  X:
  <input id="posX" type="number" value="0">
  Y:
  <input id="posY" type="number" value="0">
  Vel X:
  <input id="velX" type="number" value="0">
  Vel Y:
  <input id="velY" type="number" value="0">

  <button id="addBtn">Adicionar corpo</button>
  <button id="resetBtn">Resetar simulação</button>

</div>

<script>
/* === Config / Canvas / Camera (mobile-focused) === */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let DPR = Math.max(1, window.devicePixelRatio || 1);

function fitCanvas(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  canvas.width = Math.floor(innerWidth * DPR);
  canvas.height = Math.floor(innerHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
fitCanvas();
addEventListener('resize', fitCanvas);

const cam = { x: 0, y: 0, scale: 1 };

function worldToScreen(p){
  const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
  return { x: (p.x - cam.x)*cam.scale + cx, y: (p.y - cam.y)*cam.scale + cy };
}

function screenToWorld(sx, sy){
  const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
  return { x: cam.x + (sx - cx)/cam.scale, y: cam.y + (sy - cy)/cam.scale };
}

/* === Simulation state === */
let G = parseFloat(document.getElementById('gRange').value);
let dt = parseFloat(document.getElementById('dtRange').value);
const MAX_TRAIL = 450;

function makeBody(m, x, y, vx=0, vy=0){
  return { m, x, y, vx, vy, rgb: [200,200,255], trail: [] };
}

let bodies = [
  makeBody(20, -150, 0, 0, 1.2),
  makeBody(20, 150, 0, 0, -1.2),
  makeBody(35, 0, 0, 0, 0)
];

function recomputeColors(){
  if(bodies.length === 0) return;
  let minM = Infinity, maxM = -Infinity;
  for(const b of bodies){ if(b.m < minM) minM = b.m; if(b.m > maxM) maxM = b.m; }
  if(minM === maxM){ minM = minM * 0.5; maxM = maxM * 1.5; if(minM===maxM){ minM = 0; maxM = maxM||1; } }

  for(const b of bodies){
    let t = (b.m - minM) / (maxM - minM);
    t = Math.max(0, Math.min(1, t));

    let r,g,bb;
    if(t < 0.25){
      let u = t/0.25;
      r = lerp(40, 0, u); g = lerp(90,180,u); bb = lerp(255,200,u);
    } else if(t < 0.5){
      let u = (t-0.25)/0.25;
      r = lerp(0,180,u); g = lerp(180,220,u); bb = lerp(200,80,u);
    } else if(t < 0.75){
      let u = (t-0.5)/0.25;
      r = lerp(180,240,u); g = lerp(220,160,u); bb = lerp(80,40,u);
    } else {
      let u = (t-0.75)/0.25;
      r = lerp(240,255,u); g = lerp(160,100,u); bb = lerp(40,20,u);
    }
    b.rgb = [r|0, g|0, bb|0];
  }
}

function lerp(a,b,t){ return a + (b-a)*t; }

/* === Physics: Velocity Verlet === */
function computeAccs(arr){
  const n = arr.length;
  const ax = new Array(n).fill(0);
  const ay = new Array(n).fill(0);
  const eps = 1.0;

  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const A = arr[i], B = arr[j];
      const dx = B.x - A.x;
      const dy = B.y - A.y;
      const dist2 = dx*dx + dy*dy + eps;
      const dist = Math.sqrt(dist2);
      const f = G * A.m * B.m / dist2;
      const fx = f * dx / dist;
      const fy = f * dy / dist;

      ax[i] += fx / A.m; ay[i] += fy / A.m;
      ax[j] -= fx / B.m; ay[j] -= fy / B.m;
    }
  }
  return { ax, ay };
}

function stepVerlet(dtStep){
  if(bodies.length === 0) return;
  const { ax: ax0, ay: ay0 } = computeAccs(bodies);

  for(let i=0;i<bodies.length;i++){
    const b = bodies[i];
    b.x += b.vx * dtStep + 0.5 * ax0[i] * dtStep * dtStep;
    b.y += b.vy * dtStep + 0.5 * ay0[i] * dtStep * dtStep;
  }

  const { ax: ax1, ay: ay1 } = computeAccs(bodies);

  for(let i=0;i<bodies.length;i++){
    const b = bodies[i];
    b.vx += 0.5 * (ax0[i] + ax1[i]) * dtStep;
    b.vy += 0.5 * (ay0[i] + ay1[i]) * dtStep;

    b.trail.push({ x: b.x, y: b.y });
    if(b.trail.length > MAX_TRAIL) b.trail.shift();
  }
}

/* === Rendering === */
function draw(){
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

  recomputeColors();

  ctx.lineWidth = 1;
  ctx.setLineDash([6,6]);

  for(const b of bodies){
    if(b.trail.length < 2) continue;
    ctx.beginPath();
    ctx.strokeStyle = `rgba(${b.rgb[0]},${b.rgb[1]},${b.rgb[2]},0.28)`;
    for(let i=0;i<b.trail.length-1;i++){
      const p1 = worldToScreen(b.trail[i]);
      const p2 = worldToScreen(b.trail[i+1]);
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    ctx.stroke();
  }

  ctx.setLineDash([]);

  for(const b of bodies){
    const screen = worldToScreen(b);
    const radius = Math.max(4, Math.log(b.m + 1) * 4) * cam.scale;

    ctx.beginPath();
    ctx.arc(screen.x, screen.y, Math.max(3, radius), 0, Math.PI*2);
    ctx.fillStyle = `rgb(${b.rgb[0]},${b.rgb[1]},${b.rgb[2]})`;
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = `rgba(${b.rgb[0]},${b.rgb[1]},${b.rgb[2]},0.9)`;
    ctx.stroke();
  }
}

/* === Main loop === */
let last = performance.now();
function loop(){
  stepVerlet(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* === UI === */
const uiBtn = document.getElementById('uiBtn');
const panel = document.getElementById('panel');
const closePanelBtn = document.getElementById('closePanelBtn');

uiBtn.onclick = () => {
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
};

closePanelBtn.onclick = () => {
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden', 'true');
};

document.getElementById('addBtn').onclick = () => {
  const m = parseFloat(document.getElementById('massa').value) || 10;
  const x = parseFloat(document.getElementById('posX').value) || 0;
  const y = parseFloat(document.getElementById('posY').value) || 0;
  const vx = parseFloat(document.getElementById('velX').value) || 0;
  const vy = parseFloat(document.getElementById('velY').value) || 0;
  bodies.push(makeBody(m, x, y, vx, vy));
  recomputeColors();
};

document.getElementById('resetBtn').onclick = () => {
  bodies = [
    makeBody(20, -150, 0, 0, 1.2),
    makeBody(20, 150, 0, 0, -1.2),
    makeBody(35, 0, 0, 0, 0)
  ];
  cam.x = 0; cam.y = 0; cam.scale = 1;
  recomputeColors();
};

document.getElementById('gRange').oninput = (e)=>{
  G = parseFloat(e.target.value);
  document.getElementById('gVal').textContent = `G = ${G.toFixed(2)}`;
};

document.getElementById('dtRange').oninput = (e)=>{
  dt = parseFloat(e.target.value);
  document.getElementById('dtVal').textContent = `dt = ${dt.toFixed(2)}`;
};

/* === Touch handling (mobile) === */
let ongoingTouches = [];
let touchState = {
  mode: 'idle',
  startWorld: null,
  startScreen: null,
  lastPan: null,
  lastDist: 0,
  lastCenter: null
};

function distTouches(a,b){
  const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY;
  return Math.hypot(dx,dy);
}
function centerTouches(a,b){
  return { x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 };
}

canvas.addEventListener('touchstart', (ev) => {
  ev.preventDefault();
  const touches = ev.touches;

  if(touches.length === 1){
    touchState.mode = 'creating';
    const t = touches[0];
    touchState.startScreen = { x: t.clientX, y: t.clientY };
    touchState.startWorld = screenToWorld(t.clientX, t.clientY);
    touchState.lastPan = { x: t.clientX, y: t.clientY };
  } else if(touches.length === 2){
    touchState.mode = 'pinch';
    const a = touches[0], b = touches[1];
    touchState.lastDist = distTouches(a,b);
    touchState.lastCenter = centerTouches(a,b);
    touchState.pinchRefWorld = screenToWorld(touchState.lastCenter.x, touchState.lastCenter.y);
    touchState.startScale = cam.scale;
  }
}, { passive:false });

canvas.addEventListener('touchmove', (ev) => {
  ev.preventDefault();
  const touches = ev.touches;

  if(touches.length === 1 && touchState.mode === 'creating'){
    touchState.lastPan = { x: touches[0].clientX, y: touches[0].clientY };

  } else if(touches.length === 1 && touchState.mode === 'pan'){
    const t = touches[0];
    const dx = t.clientX - touchState.lastPan.x;
    const dy = t.clientY - touchState.lastPan.y;
    touchState.lastPan = { x: t.clientX, y: t.clientY };
    cam.x -= dx / cam.scale;
    cam.y -= dy / cam.scale;

  } else if(touches.length === 2 && touchState.mode === 'pinch'){
    const a = touches[0], b = touches[1];
    const newDist = distTouches(a,b);
    const center = centerTouches(a,b);

    const factor = newDist / (touchState.lastDist || newDist);
    const newScale = Math.max(0.08, Math.min(8, touchState.startScale * factor));

    const screenCenter = { x: center.x, y: center.y };
    const worldAtScreenBefore = touchState.pinchRefWorld;

    cam.scale = newScale;
    cam.x = worldAtScreenBefore.x - (screenCenter.x - canvas.clientWidth/2) / cam.scale;
    cam.y = worldAtScreenBefore.y - (screenCenter.y - canvas.clientHeight/2) / cam.scale;
  }

}, { passive:false });

canvas.addEventListener('touchend', (ev) => {
  ev.preventDefault();

  if(touchState.mode === 'creating'){
    const changed = ev.changedTouches[0];
    if(changed){
      const endScreen = { x: changed.clientX, y: changed.clientY };
      const startScreen = touchState.startScreen;
      const dx = endScreen.x - startScreen.x;
      const dy = endScreen.y - startScreen.y;

      const vx = dx * 0.02;
      const vy = dy * 0.02;

      const m = parseFloat(document.getElementById('massa').value) || 10;
      const pos = touchState.startWorld;

      bodies.push(makeBody(m, pos.x, pos.y, vx, vy));
      recomputeColors();
    }
  }

  touchState.mode = 'idle';
  touchState.lastDist = 0;
  touchState.pinchRefWorld = null;

}, { passive:false });

canvas.addEventListener('touchcancel', () => {
  touchState.mode='idle';
});

/* === Double tap resets camera === */
canvas.addEventListener('dblclick', () => {
  cam.x = 0; cam.y = 0; cam.scale = 1;
});

/* === Long press to pan === */
let holdTimer = null;
const HOLD_MS = 220;

canvas.addEventListener('touchstart', (ev) => {
  if(ev.touches.length !== 1) return;
  clearTimeout(holdTimer);
  const t = ev.touches[0];
  holdTimer = setTimeout(() => {
    touchState.mode = 'pan';
    touchState.lastPan = { x: t.clientX, y: t.clientY };
  }, HOLD_MS);
}, { passive:false });

canvas.addEventListener('touchmove', (ev) => {
  if(ev.touches.length === 1 && touchState.mode === 'pan'){
    const t = ev.touches[0];
    const dx = t.clientX - touchState.lastPan.x;
    const dy = t.clientY - touchState.lastPan.y;
    touchState.lastPan = { x: t.clientX, y: t.clientY };
    cam.x -= dx / cam.scale;
    cam.y -= dy / cam.scale;

  } else {
    if(ev.touches.length === 1 && touchState.mode === 'creating'){
      const t = ev.touches[0];
      const dx = t.clientX - touchState.startScreen.x;
      const dy = t.clientY - touchState.startScreen.y;
      if(Math.hypot(dx,dy) > 8){
        clearTimeout(holdTimer);
      }
    }
  }

}, { passive:false });

canvas.addEventListener('touchend', () => {
  clearTimeout(holdTimer);
}, { passive:false });

window.addEventListener('orientationchange', () => {
  fitCanvas();
});

/* === init colors === */
recomputeColors();
</script>

</body>
</html>
