<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Evolução de Sistemas Planetários</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; background:#000; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
// CONFIGURAÇÃO
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const WIDTH = canvas.width;
const HEIGHT = canvas.height;

const POP_SIZE = 20;       // número de agentes
const N_CORPOS = 10;       // corpos por agente
const G = 1;               // constante gravitacional simplificada
const TIMESTEP = 0.5;      // passo da simulação
const MAX_STEPS = 500;     // passos por avaliação
const MUTATION_RATE = 0.05;
const TOP_SELECTION = 0.2; // top 20%

// FUNÇÕES AUXILIARES
function rand(a,b){ return Math.random()*(b-a)+a; }

// CRIA UM AGENTE
function criarAgente(){
  const corpos = [];
  for(let i=0;i<N_CORPOS;i++){
    corpos.push({
      x: rand(WIDTH*0.3, WIDTH*0.7),
      y: rand(HEIGHT*0.3, HEIGHT*0.7),
      vx: rand(-1,1),
      vy: rand(-1,1),
      m: rand(1,5)
    });
  }
  return corpos;
}

// CLONE COM MUTACAO
function mutar(corpos){
  return corpos.map(c=>({
    x: c.x * (1 + rand(-MUTATION_RATE,MUTATION_RATE)),
    y: c.y * (1 + rand(-MUTATION_RATE,MUTATION_RATE)),
    vx: c.vx * (1 + rand(-MUTATION_RATE,MUTATION_RATE)),
    vy: c.vy * (1 + rand(-MUTATION_RATE,MUTATION_RATE)),
    m: c.m * (1 + rand(-MUTATION_RATE,MUTATION_RATE))
  }));
}

// SIMULA UM AGENTE E RETORNA FITNESS (órbitas estáveis)
function fitness(corpos){
  // clone profundo para não alterar original
  const sim = corpos.map(c=>({...c}));
  let score = 0;

  for(let step=0; step<MAX_STEPS; step++){
    // cálculo das forças gravitacionais
    for(let i=0;i<sim.length;i++){
      let fx=0, fy=0;
      for(let j=0;j<sim.length;j++){
        if(i===j) continue;
        const dx = sim[j].x - sim[i].x;
        const dy = sim[j].y - sim[i].y;
        const dist2 = dx*dx + dy*dy;
        const dist = Math.sqrt(dist2) + 0.1; // evitar divisão por zero
        const f = G * sim[i].m * sim[j].m / dist2;
        fx += f * dx / dist;
        fy += f * dy / dist;
      }
      // atualiza velocidade
      sim[i].vx += fx/sim[i].m * TIMESTEP;
      sim[i].vy += fy/sim[i].m * TIMESTEP;
    }
    // atualiza posições
    for(let i=0;i<sim.length;i++){
      sim[i].x += sim[i].vx * TIMESTEP;
      sim[i].y += sim[i].vy * TIMESTEP;
      // checar se ainda está dentro da tela (simplificação)
      if(sim[i].x>0 && sim[i].x<WIDTH && sim[i].y>0 && sim[i].y<HEIGHT){
        score += 1; // cada corpo que permanece "estável" aumenta score
      }
    }
  }
  return score;
}

// SELEÇÃO NATURAL
function novaGeracao(pop){
  pop.sort((a,b)=>fitness(b.corpos)-fitness(a.corpos));
  const top = pop.slice(0, Math.ceil(POP_SIZE*TOP_SELECTION));
  const novaPop = [];
  while(novaPop.length < POP_SIZE){
    const pai = top[Math.floor(Math.random()*top.length)];
    novaPop.push({corpos: mutar(pai.corpos)});
  }
  return novaPop;
}

// INICIALIZA POPULAÇÃO
let populacao = [];
for(let i=0;i<POP_SIZE;i++){
  populacao.push({corpos: criarAgente()});
}

let geracao = 1;

// DESENHO
function desenhar(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  const melhor = populacao[0].corpos;
  for(const c of melhor){
    ctx.beginPath();
    ctx.arc(c.x,c.y,c.m*2,0,Math.PI*2);
    ctx.fillStyle = "#0a84ff";
    ctx.fill();
  }
  ctx.fillStyle = "#fff";
  ctx.fillText("Geração: "+geracao,10,20);
}

// LOOP PRINCIPAL
function loop(){
  // Evolução
  populacao = novaGeracao(populacao);
  geracao++;
  desenhar();
  requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>
