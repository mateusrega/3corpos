<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3-Corpos — Verlet (Drawer Left)</title>
<style>
  :root{
    --bg:#000;
    --panel:#08121a;
    --ui:#e6eef8;
    --accent:#06b6d4;
    --muted:rgba(230,238,248,0.07);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ui);font-family:Inter,Roboto,system-ui,-apple-system,Segoe UI,Arial;}
  #container{position:relative;height:100vh;width:100vw;overflow:hidden}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#030308 0%,#000000 100%);touch-action:none}

  /* Floating button (bottom-left) opens drawer */
  #openBtn{
    position:fixed;
    left:16px;
    bottom:16px;
    z-index:60;
    width:54px;
    height:54px;
    border-radius:50%;
    background:linear-gradient(180deg,var(--accent),#0891b2);
    border:none;
    box-shadow:0 6px 18px rgba(0,0,0,0.45);
    color:#022;
    font-size:20px;
    cursor:pointer;
    display:flex;align-items:center;justify-content:center;
  }

  /* Drawer / panel - slides from left */
  #drawer{
    position:fixed;
    left:-320px;
    top:0;
    width:320px;
    height:100vh;
    background:var(--panel);
    box-shadow:6px 0 40px rgba(0,0,0,0.6);
    z-index:70;
    transition:left 280ms cubic-bezier(.2,.9,.2,1);
    padding:18px;
    box-sizing:border-box;
  }
  #drawer.open{ left:0; }

  #drawer h3{ margin:0 0 10px 0; font-size:16px; color:var(--ui); }
  .row{ margin:10px 0; display:flex; align-items:center; gap:8px; }
  label.small{ font-size:13px; color:#9fb6c4; min-width:48px; display:inline-block;}
  input[type=range]{ flex:1; }
  input[type=number]{ width:100%; padding:8px; border-radius:8px; border:0; background:var(--muted); color:var(--ui); }

  button.primary{
    width:100%;
    padding:10px 12px;
    border-radius:8px;
    background:var(--accent);
    color:#022;
    border:0;
    font-weight:700;
    cursor:pointer;
  }
  button.ghost{
    width:100%;
    padding:8px;
    border-radius:8px;
    background:transparent;
    border:1px solid rgba(255,255,255,0.04);
    color:var(--ui);
    cursor:pointer;
  }
  .muted{ font-size:12px; color:#93bac6; }

  /* close icon inside drawer */
  #closeDrawer{ position:absolute; right:12px; top:12px; background:transparent; border:0; color:#9fb6c4; font-size:18px; cursor:pointer; }

  /* footer info */
  .footer{
    position:fixed; right:12px; bottom:16px; z-index:60;
    background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; font-size:12px; color:#9fb6c4;
  }

  /* preview arrow canvas overlay (optional) */
  #overlay{ position:fixed; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:65; }
</style>
</head>
<body>
  <div id="container">
    <canvas id="sim" aria-label="Simulação 3 corpos"></canvas>

    <button id="openBtn" title="Abrir painel">⚙</button>

    <aside id="drawer" aria-hidden="true">
      <button id="closeDrawer" aria-label="Fechar painel">✕</button>
      <h3>Configuração — Simulação</h3>

      <div class="row">
        <label class="small">Vel (dt)</label>
        <input id="dtRange" type="range" min="0.05" max="2.0" step="0.05" value="0.5">
      </div>
      <div class="row">
        <span class="muted" id="dtVal">dt ×0.50</span>
      </div>

      <div class="row">
        <label class="small">G</label>
        <input id="gRange" type="range" min="0.01" max="1.0" step="0.01" value="0.2">
      </div>
      <div class="row">
        <span class="muted" id="gVal">G = 0.20</span>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:12px 0;">

      <div style="margin-top:8px;">
        <button id="addBtn" class="primary">Adicionar corpo aleatório</button>
        <div style="height:8px"></div>
        <button id="resetBtn" class="ghost">Resetar cena</button>
      </div>

      <div style="margin-top:12px;" class="muted">Toque/arraste para criar corpo: início = posição, arraste = velocidade. Segurar para pan, dois dedos para zoom.</div>
    </aside>

    <div class="footer">Rastro: ≤150 pontos • 450 px visíveis • Max corpos recomendado: 60</div>

    <!-- overlay for preview arrow (optional) -->
    <canvas id="overlay"></canvas>
  </div>

<script>
/* ======================================================
   Config & Canvas
   ====================================================== */
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d', { alpha: false });
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');

function resizeAll(){
  const dpr = window.devicePixelRatio || 1;
  // main canvas
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // overlay
  overlay.style.width = window.innerWidth + 'px';
  overlay.style.height = window.innerHeight + 'px';
  overlay.width = Math.floor(window.innerWidth * dpr);
  overlay.height = Math.floor(window.innerHeight * dpr);
  octx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeAll);
resizeAll();

/* ======================================================
   Simulation state
   ====================================================== */
const bodies = []; // array of {m,x,y,vx,vy,trail}
let G = parseFloat(document.getElementById('gRange').value) || 0.2;
let dtMul = parseFloat(document.getElementById('dtRange').value) || 0.5; // user multiplier
const BASE_STEP = 0.016; // base 60Hz step
const MAX_SUBSTEPS = 12;
const MAX_TRAIL_POINTS = 150;
const TRAIL_MAX_PX = 450;
const MAX_BODIES = 120; // hard cap to avoid O(n^2) blowup

function makeBody(m,x,y,vx=0,vy=0){
  return { m, x, y, vx, vy, trail: [[x,y]] };
}

/* seed initial 3-body centered roughly in world coords (screen space used for convenience) */
function seedDefault(){
  bodies.length = 0;
  const cx = window.innerWidth/2, cy = window.innerHeight/2;
  bodies.push(makeBody(200, cx, cy, 0, 0));
  bodies.push(makeBody(20, cx-150, cy, 0, 1.2));
  bodies.push(makeBody(20, cx+150, cy, 0, -1.2));
}
seedDefault();

/* ======================================================
   Physics: Velocity Verlet with substeps
   - We'll compute per-frame a small number of substeps depending on dtMul
   ====================================================== */
function physicsStep(stepDt){
  const n = bodies.length;
  if(n === 0) return;

  // arrays for accelerations (avoid re-alloc per pair by reusing)
  const ax = new Array(n).fill(0);
  const ay = new Array(n).fill(0);

  // pairwise accel at current positions
  for(let i=0;i<n;i++){
    const Ai = bodies[i];
    for(let j=i+1;j<n;j++){
      const Aj = bodies[j];
      const dx = Aj.x - Ai.x;
      const dy = Aj.y - Ai.y;
      const dist2 = dx*dx + dy*dy + 9.0; // softening: 3^2 to stabilize close passes
      const inv = 1 / Math.sqrt(dist2);
      const f = G * Ai.m * Aj.m * inv * inv; // F = G*m1*m2/r^2
      const fx = f * dx * inv;
      const fy = f * dy * inv;
      ax[i] += fx / Ai.m; ay[i] += fy / Ai.m;
      ax[j] -= fx / Aj.m; ay[j] -= fy / Aj.m;
    }
  }

  // update positions using Verlet style
  for(let i=0;i<n;i++){
    const b = bodies[i];
    b.x += b.vx * stepDt + 0.5 * ax[i] * stepDt * stepDt;
    b.y += b.vy * stepDt + 0.5 * ay[i] * stepDt * stepDt;
  }

  // recompute accs at new positions
  ax.fill(0); ay.fill(0);
  for(let i=0;i<n;i++){
    const Ai = bodies[i];
    for(let j=i+1;j<n;j++){
      const Aj = bodies[j];
      const dx = Aj.x - Ai.x;
      const dy = Aj.y - Ai.y;
      const dist2 = dx*dx + dy*dy + 9.0;
      const inv = 1 / Math.sqrt(dist2);
      const f = G * Ai.m * Aj.m * inv * inv;
      const fx = f * dx * inv;
      const fy = f * dy * inv;
      ax[i] += fx / Ai.m; ay[i] += fy / Ai.m;
      ax[j] -= fx / Aj.m; ay[j] -= fy / Aj.m;
    }
  }

  // finish velocity update and append trails (bounded)
  for(let i=0;i<n;i++){
    const b = bodies[i];
    b.vx += 0.5 * ax[i] * stepDt;
    b.vy += 0.5 * ay[i] * stepDt;

    // push trail point (simple sampling) and cap points
    const last = b.trail[b.trail.length-1];
    if(!last || last[0] !== b.x || last[1] !== b.y){
      b.trail.push([b.x, b.y]);
      if(b.trail.length > MAX_TRAIL_POINTS) b.trail.shift();
    }
  }
}

/* ======================================================
   Drawing: trails limited by px length + bodies
   ====================================================== */
function draw(){
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

  // trails (tracejado) — cyan-ish
  ctx.lineWidth = 1.2;
  ctx.setLineDash([6,6]);
  ctx.strokeStyle = '#7dd3fc';

  for(const b of bodies){
    if(b.trail.length < 2) continue;

    // accumulate from newest backwards until pixel limit
    let acc = 0;
    const drawPts = [];
    for(let i = b.trail.length - 1; i > 0; i--){
      const p1 = b.trail[i];
      const p0 = b.trail[i-1];
      const dx = p1[0] - p0[0], dy = p1[1] - p0[1];
      const d = Math.hypot(dx,dy);
      acc += d;
      drawPts.unshift(p1);
      if(acc >= TRAIL_MAX_PX) break;
    }
    // ensure include current last if not present
    if(b.trail.length) drawPts.push(b.trail[b.trail.length-1]);

    // draw polyline
    ctx.beginPath();
    for(let i=0;i<drawPts.length;i++){
      const p = drawPts[i];
      if(i===0) ctx.moveTo(p[0], p[1]); else ctx.lineTo(p[0], p[1]);
    }
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // draw bodies
  for(const b of bodies){
    ctx.beginPath();
    const r = Math.max(3, Math.log2(b.m + 1) * 3);
    ctx.arc(b.x, b.y, r, 0, Math.PI*2);
    ctx.fillStyle = rgbForMass(b.m);
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.stroke();
  }
}

/* simple color picker (consistent with earlier gradient) */
function rgbForMass(m){
  const [r,g,b] = massToRGB(m);
  return `rgb(${r},${g},${b})`;
}
function massToRGB(m){
  const minM=5, maxM=60;
  let t = (m - minM) / (maxM - minM);
  t = Math.max(0, Math.min(1, t));
  if(t < 0.5){
    const u = t/0.5;
    const r = Math.round(0 + (0-0)*u);
    const g = Math.round(120 + (200-120)*u);
    const b = Math.round(255 + (80-255)*u);
    return [r,g,b];
  } else {
    const u = (t-0.5)/0.5;
    const r = Math.round(0 + (255-0)*u);
    const g = Math.round(200 + (120-200)*u);
    const b = Math.round(80 + (30-80)*u);
    return [r,g,b];
  }
}

/* ======================================================
   Main RAF loop with adaptive substepping
   ====================================================== */
let last = performance.now();
function frame(now){
  const elapsed = (now - last) / 1000;
  last = now;
  // clamp (handle tab switch)
  const clamped = Math.min(0.05, elapsed);

  // compute desired simulation time this frame
  const simTime = clamped * dtMul; // scale real time by dtMul slider
  // pick number of substeps to keep each step <= BASE_STEP * 1.2 (approx)
  let steps = Math.ceil(simTime / (BASE_STEP * 1.0));
  steps = Math.max(1, Math.min(MAX_SUBSTEPS, steps));
  const stepSize = simTime / steps;

  // run physics steps
  for(let i=0;i<steps;i++) physicsStep(stepSize);

  // draw
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* ======================================================
   Input: pointer for create / pan / pinch (pointer events)
   - single pointer: tap & drag to create body (release spawns)
   - hold + drag: pan
   - two pointers: pinch to zoom
   ====================================================== */
let pointers = new Map();
let create = { active:false, id:null, startScreen:null, startWorld:null, held:false, holdTimer:null, lastMove:null };

let pinchRef = null;

canvas.addEventListener('pointerdown', (ev)=>{
  canvas.setPointerCapture(ev.pointerId);
  pointers.set(ev.pointerId, { id:ev.pointerId, x:ev.clientX, y:ev.clientY, type:ev.pointerType });

  if(pointers.size === 1){
    // start potential create
    create.active = true;
    create.id = ev.pointerId;
    create.startScreen = { x: ev.clientX, y: ev.clientY };
    create.startWorld = { x: ev.clientX, y: ev.clientY }; // world==screen space here
    create.held = false;
    create.lastMove = null;
    create.holdTimer = setTimeout(()=>{ create.held = true; }, 220);
  } else if(pointers.size === 2){
    // pinch start
    const arr = Array.from(pointers.values());
    const a = arr[0], b = arr[1];
    pinchRef = {
      dist: Math.hypot(a.x - b.x, a.y - b.y),
      center: { x: (a.x + b.x)/2, y: (a.y + b.y)/2 },
      cam: { x: 0, y: 0, scale: cam.scale } // cam.x,y are zero in screen-coords design
    };
  }
});

canvas.addEventListener('pointermove', (ev)=>{
  if(!pointers.has(ev.pointerId)) return;
  pointers.set(ev.pointerId, { id:ev.pointerId, x:ev.clientX, y:ev.clientY, type:ev.pointerType });

  if(pointers.size === 2 && pinchRef){
    const arr = Array.from(pointers.values());
    const a = arr[0], b = arr[1];
    const newDist = Math.hypot(a.x - b.x, a.y - b.y);
    const factor = newDist / pinchRef.dist;
    // adjust cam.scale but clamp
    cam.scale = Math.max(0.08, Math.min(8, pinchRef.cam.scale * factor));
    return;
  }

  // single pointer: if held -> pan, else update preview
  if(create.active && ev.pointerId === create.id){
    if(create.held){
      const last = create.lastMove || create.startScreen;
      const dx = ev.clientX - last.x;
      const dy = ev.clientY - last.y;
      // pan (camera implemented as offset; here worlds are screen coords so move all bodies)
      for(const b of bodies){ b.x += dx; b.y += dy; }
      create.lastMove = { x: ev.clientX, y: ev.clientY };
    } else {
      // preview velocity stored in create.previewV (not drawn on main canvas here)
      // we keep simple: no visual preview except overlay optional
    }
  }
});

canvas.addEventListener('pointerup', (ev)=>{
  if(!pointers.has(ev.pointerId)) return;
  pointers.delete(ev.pointerId);
  canvas.releasePointerCapture(ev.pointerId);

  if(create.active && ev.pointerId === create.id){
    clearTimeout(create.holdTimer);
    if(!create.held){
      // create body with velocity defined by drag vector
      const end = { x: ev.clientX, y: ev.clientY };
      const vx = (end.x - create.startScreen.x) * 0.04;
      const vy = (end.y - create.startScreen.y) * 0.04;
      if(bodies.length < MAX_BODIES){
        const mass = Math.min(60, 5 + Math.random()*40);
        bodies.push(makeBody(mass, create.startWorld.x, create.startWorld.y, vx, vy));
      }
    }
    // reset create
    create.active = false;
    create.id = null;
    create.startScreen = null;
    create.startWorld = null;
    create.held = false;
    create.lastMove = null;
  }

  if(pointers.size < 2) pinchRef = null;
});

/* wheel zoom for desktop */
canvas.addEventListener('wheel', (ev)=>{
  ev.preventDefault();
  const factor = Math.exp(-ev.deltaY * 0.0015);
  cam.scale = Math.max(0.08, Math.min(8, cam.scale * factor));
},{passive:false});

/* prevent accidental text selection while dragging */
canvas.addEventListener('pointermove', (ev)=>{ if(create.active) ev.preventDefault(); });

/* ======================================================
   UI bindings
   ====================================================== */
const dtRange = document.getElementById('dtRange');
const gRange = document.getElementById('gRange');
const dtVal = document.getElementById('dtVal');
const gVal = document.getElementById('gVal');
const resetBtn = document.getElementById('resetBtn');
const addBtn = document.getElementById('addBtn');
const openBtn = document.getElementById('openBtn');
const drawer = document.getElementById('drawer');
const closeDrawer = document.getElementById('closeDrawer');

dtRange.value = dtMul;
dtVal.textContent = `dt ×${dtMul.toFixed(2)}`;
gVal.textContent = `G = ${G.toFixed(2)}`;

dtRange.addEventListener('input', (e)=>{
  dtMul = parseFloat(e.target.value);
  dtVal.textContent = `dt ×${dtMul.toFixed(2)}`;
});
gRange.addEventListener('input', (e)=>{
  G = parseFloat(e.target.value);
  gVal.textContent = `G = ${G.toFixed(2)}`;
});

resetBtn.addEventListener('click', ()=>{
  seedDefault();
});
addBtn.addEventListener('click', ()=>{
  if(bodies.length >= MAX_BODIES) return;
  const sx = window.innerWidth/2 + (Math.random()-0.5)*300;
  const sy = window.innerHeight/2 + (Math.random()-0.5)*200;
  const mass = 8 + Math.random()*40;
  const vx = (Math.random()-0.5)*1.4;
  const vy = (Math.random()-0.5)*1.4;
  bodies.push(makeBody(mass, sx, sy, vx, vy));
});

openBtn.addEventListener('click', ()=>{
  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden', 'false');
});
closeDrawer.addEventListener('click', ()=>{
  drawer.classList.remove('open');
  drawer.setAttribute('aria-hidden', 'true');
});

/* ======================================================
   helpers & init
   ====================================================== */
/* mass color helper used by draw: massToRGB defined above reused */
function corPorMassaRGB(m){ return massToRGB(m); } // backwards compat

// initialize UI & ensure resize applied
dtRange.dispatchEvent(new Event('input'));
gRange.dispatchEvent(new Event('input'));
resizeAll();

</script>
</body>
</html>
